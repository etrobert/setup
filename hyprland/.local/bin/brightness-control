#!/usr/bin/env bash

set -o errexit
set -o nounset
set -o pipefail

if [ $# -eq 0 ]; then
  echo "Usage: brightness-control [up|down]"
  exit 1
fi

DIRECTION=$1

notify_brightness() {
  local percent=$1
  notify-send -h int:value:"$percent" \
    -h string:x-canonical-private-synchronous:brightness \
    "Brightness" "$percent%"
}

# Get focused monitor name
FOCUSED_MONITOR=$(hyprctl monitors -j | jq -r '.[] | select(.focused == true) | .name')

case "$FOCUSED_MONITOR" in
eDP-*)
  # Laptop display - use brightnessctl
  if [ "$DIRECTION" = "up" ]; then
    brightnessctl -e4 -n2 set 5%+
  elif [ "$DIRECTION" = "down" ]; then
    brightnessctl -e4 -n2 set 5%-
  fi
  PERCENT=$(brightnessctl -m | cut -d, -f4 | tr -d %)
  notify_brightness "$PERCENT"
  ;;
*)
  # External monitor - use ddcutil
  # Use flock to serialize I2C access so rapid keypresses queue up.
  # The background subshell holds the lock until getvcp finishes,
  # preventing I2C bus conflicts between concurrent invocations.
  LOCKFILE="/tmp/brightness-control.lock"
  (
    flock 9
    if [ "$DIRECTION" = "up" ]; then
      ddcutil setvcp 10 + 10 --noverify
    elif [ "$DIRECTION" = "down" ]; then
      ddcutil setvcp 10 - 10 --noverify
    fi
    read -r _ _ _ val max < <(ddcutil getvcp 10 --brief 2>/dev/null)
    [ -n "$val" ] && notify_brightness "$((val * 100 / max))"
  ) 9>"$LOCKFILE" &
  ;;
esac
